{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IBzxProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n\ninterface IBzxProtocol {\n    function underlyingToLoanPool(address underlying) external view returns (address loanPool);\n}\n"
    },
    "contracts/wrappers/FulcrumWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/ILoanToken.sol\";\nimport \"../interfaces/IBzxProtocol.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract FulcrumWrapper is IWrapper {\n    using SafeMath for uint256;\n\n    IBzxProtocol private constant _BZX_PROTOCOL = IBzxProtocol(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n\n    mapping(IERC20 => IERC20) public iTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToiToken;\n\n    function addMarkets(IERC20[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            address loanPool = _BZX_PROTOCOL.underlyingToLoanPool(address(markets[i]));\n            require(loanPool != address(0), \"Token is not supported\");\n            iTokenToToken[IERC20(loanPool)] = markets[i];\n            tokenToiToken[markets[i]] = IERC20(loanPool);\n        }\n    }\n\n    function removeMarkets(IERC20[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            address loanPool = _BZX_PROTOCOL.underlyingToLoanPool(address(markets[i]));\n            require(loanPool == address(0), \"Token is still supported\");\n            delete iTokenToToken[IERC20(loanPool)];\n            delete tokenToiToken[markets[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = iTokenToToken[token];\n        IERC20 iToken = tokenToiToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, uint256(1e36).div(ILoanToken(address(token)).tokenPrice()));\n        } else if (iToken != IERC20(0)) {\n            return (iToken, ILoanToken(address(iToken)).tokenPrice());\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/ILoanToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n\ninterface ILoanToken {\n    function tokenPrice() external view returns (uint256 price);\n    function loanTokenAddress() external view returns (address underlying);\n}\n"
    },
    "contracts/interfaces/IWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IWrapper {\n    function wrap(IERC20 token) external view returns (IERC20 wrappedToken, uint256 rate);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/wrappers/YVaultWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IWrapper.sol\";\nimport \"../interfaces/IYVault.sol\";\n\ncontract YVaultWrapper is IWrapper {\n    // only unwrapping is supported for now\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IYVault vault = IYVault(address(token));\n        wrappedToken = vault.token();\n        try vault.token() returns(IERC20 _token) {\n            wrappedToken = _token;\n            try vault.getPricePerFullShare() returns(uint256 _rate) {\n                // vault V1\n                rate = _rate;\n            } catch {\n                try vault.pricePerShare() returns(uint256 _rate) {\n                    // vault V2\n                    uint8 decimals = ERC20(address(wrappedToken)).decimals();\n                    rate = _rate * (10 ** 18) / (10 ** decimals);\n                } catch {\n                    revert(\"Unsupported token\");\n                }\n            }\n        } catch {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/IYVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IYVault {\n    function getPricePerFullShare() external view returns(uint256 price);\n    function pricePerShare() external view returns(uint256 price);\n    function token() external view returns(IERC20);\n}\n\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/oracles/UniswapV3Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"../libraries/Sqrt.sol\";\n\n\ncontract UniswapV3Oracle is IOracle {\n    using Address for address;\n    using SafeMath for uint256;\n    using Sqrt for uint256;\n\n    bytes32 public immutable poolInitCodeHash;\n    address public constant FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n    IERC20 private constant _NONE = IERC20(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    constructor(bytes32 _poolInitCodeHash) {\n        poolInitCodeHash = _poolInitCodeHash;\n    }\n\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external override view returns (uint256 rate, uint256 weight) {\n        uint24[3] memory fees = [uint24(500), 3000, 10000];\n        for (uint256 i = 0; i < 3; i++) {\n            (uint256 rateForFee, uint256 weightForFee) = getRateForFee(srcToken, dstToken, connector, fees[i]);\n            rate = rate.add(rateForFee.mul(weightForFee));\n            weight = weight.add(weightForFee);\n        }\n        if (weight > 0) {\n            rate = rate.div(weight);\n            weight = weight.sqrt();\n        }\n    }\n\n    // @dev fee in ppm (e.g. 3000 for 0.3% fee)\n    function getRateForFee(IERC20 srcToken, IERC20 dstToken, IERC20 connector, uint24 fee) public view returns (uint256 rate, uint256 weight) {\n        uint256 balance0;\n        uint256 balance1;\n        if (connector == _NONE) {\n            (rate, balance0, balance1) = _getRate(srcToken, dstToken, fee);\n        } else {\n            uint256 balanceConnector0;\n            uint256 balanceConnector1;\n            uint256 rate0;\n            uint256 rate1;\n            (rate0, balance0, balanceConnector0) = _getRate(srcToken, connector, fee);\n            if (balance0 == 0 || balanceConnector0 == 0) {\n                return (0, 0);\n            }\n            (rate1, balanceConnector1, balance1) = _getRate(connector, dstToken, fee);\n            if (balanceConnector1 == 0 || balance1 == 0) {\n                return (0, 0);\n            }\n\n            if (balanceConnector0 > balanceConnector1) {\n                balance0 = balance0.mul(balanceConnector1).div(balanceConnector0);\n            } else {\n                balance1 = balance1.mul(balanceConnector0).div(balanceConnector1);\n            }\n\n            rate = rate0.mul(rate1).div(1e18);\n        }\n\n        weight = balance0.mul(balance1);\n    }\n\n    function _getRate(IERC20 srcToken, IERC20 dstToken, uint24 fee) internal view returns (uint256 rate, uint256 srcBalance, uint256 dstBalance) {\n        (IERC20 token0, IERC20 token1) = srcToken < dstToken ? (srcToken, dstToken) : (dstToken, srcToken);\n        address pool = _getPool(address(token0), address(token1), fee);\n        if (!pool.isContract() || IUniswapV3Pool(pool).liquidity() == 0) {\n            return (0, 0, 0);\n        }\n        (uint256 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();\n        if (srcToken == token0) {\n            rate = (uint256(1e18).mul(sqrtPriceX96) >> 96).mul(sqrtPriceX96) >> 96;\n        } else {\n            rate = uint256(1e18 << 192).div(sqrtPriceX96).div(sqrtPriceX96);\n        }\n        srcBalance = srcToken.balanceOf(address(pool));\n        dstBalance = dstToken.balanceOf(address(pool));\n    }\n\n    function _getPool(address token0, address token1, uint24 fee) private view returns (address) {\n        return address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        FACTORY,\n                        keccak256(abi.encode(token0, token1, fee)),\n                        poolInitCodeHash\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IOracle {\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view returns (uint256 rate, uint256 weight);\n}\n"
    },
    "contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IUniswapV3Pool {\n    function slot0() external view returns (uint160 sqrtPriceX96, int24, uint16, uint16, uint16, uint8, bool);\n    function token0() external view returns (IERC20 token);\n    function liquidity() external view returns (uint128);\n}\n"
    },
    "contracts/libraries/Sqrt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n\nlibrary Sqrt {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/oracles/OracleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../libraries/Sqrt.sol\";\n\n\nabstract contract OracleBase is IOracle {\n    using SafeMath for uint256;\n    using Sqrt for uint256;\n\n    IERC20 private constant _NONE = IERC20(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view override returns (uint256 rate, uint256 weight) {\n        uint256 balance0;\n        uint256 balance1;\n        if (connector == _NONE) {\n            (balance0, balance1) = _getBalances(srcToken, dstToken);\n        } else {\n            uint256 balanceConnector0;\n            uint256 balanceConnector1;\n            (balance0, balanceConnector0) = _getBalances(srcToken, connector);\n            (balanceConnector1, balance1) = _getBalances(connector, dstToken);\n            if (balanceConnector0 > balanceConnector1) {\n                balance0 = balance0.mul(balanceConnector1).div(balanceConnector0);\n            } else {\n                balance1 = balance1.mul(balanceConnector0).div(balanceConnector1);\n            }\n        }\n\n        rate = balance1.mul(1e18).div(balance0);\n        weight = balance0.mul(balance1).sqrt();\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view virtual returns (uint256 srcBalance, uint256 dstBalance);\n}\n"
    },
    "contracts/oracles/UniswapV2LikeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./OracleBase.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\n\n\ncontract UniswapV2LikeOracle is OracleBase {\n    address public immutable factory;\n    bytes32 public immutable initcodeHash;\n\n    constructor(address _factory, bytes32 _initcodeHash) {\n        factory = _factory;\n        initcodeHash = _initcodeHash;\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function _pairFor(IERC20 tokenA, IERC20 tokenB) private view returns (address pair) {\n        pair = address(uint256(keccak256(abi.encodePacked(\n                hex\"ff\",\n                factory,\n                keccak256(abi.encodePacked(tokenA, tokenB)),\n                initcodeHash\n            ))));\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256 srcBalance, uint256 dstBalance) {\n        (IERC20 token0, IERC20 token1) = srcToken < dstToken ? (srcToken, dstToken) : (dstToken, srcToken);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairFor(token0, token1)).getReserves();\n        (srcBalance, dstBalance) = srcToken == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\n\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n}\n"
    },
    "contracts/oracles/UniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IUniswapFactory.sol\";\nimport \"./OracleBase.sol\";\n\n\ncontract UniswapOracle is OracleBase {\n    IUniswapFactory private immutable _UNISWAP_FACTORY;  // solhint-disable-line var-name-mixedcase\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n\n    constructor(IUniswapFactory factory) {\n        _UNISWAP_FACTORY = factory;\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256 srcBalance, uint256 dstBalance) {\n        if (srcToken == _ETH) {\n            address exchange = _UNISWAP_FACTORY.getExchange(dstToken);\n            require(exchange != address(0), \"Pool does not exist\");\n            srcBalance = exchange.balance;\n            dstBalance = dstToken.balanceOf(exchange);\n        } else if (dstToken == _ETH) {\n            address exchange = _UNISWAP_FACTORY.getExchange(srcToken);\n            require(exchange != address(0), \"Pool does not exist\");\n            srcBalance = srcToken.balanceOf(exchange);\n            dstBalance = exchange.balance;\n        } else {\n            revert(\"Unsupported tokens\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IUniswapFactory {\n    function getExchange(IERC20 token) external view returns (address exchange);\n}\n"
    },
    "contracts/oracles/SynthetixOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/ISynthetixExchangeRates.sol\";\nimport \"../interfaces/ISynthetixProxy.sol\";\nimport \"../interfaces/ISynthetixAddressResolver.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ncontract SynthetixOracle is IOracle {\n    using SafeMath for uint256;\n\n    ISynthetixProxy public immutable proxy;\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private constant _NONE = IERC20(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n    uint256 private constant _RATE_TTL = 1 days;\n    bytes32 private constant _EXCHANGE_RATES_KEY = 0x45786368616e6765526174657300000000000000000000000000000000000000;\n    bytes32 private constant _SETH_KEY           = 0x50726f7879734554480000000000000000000000000000000000000000000000;\n    bytes32 private constant _SNX_PROXY_KEY      = 0x50726f7879455243323000000000000000000000000000000000000000000000;\n    bytes32 private constant _SUSD_PROXY_KEY     = 0x50726f7879455243323073555344000000000000000000000000000000000000;\n    bytes32 private constant _PROXY_KEY          = 0x50726f7879000000000000000000000000000000000000000000000000000000;\n    bytes private constant _SNX = \"SNX\";\n    bytes private constant _SUSD = \"sUSD\";\n\n    constructor(ISynthetixProxy _proxy) {\n        proxy = _proxy;\n    }\n\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view override returns (uint256 rate, uint256 weight) {\n        require(connector == _NONE, \"SO: connector should be None\");\n        ISynthetixAddressResolver resolver = ISynthetixAddressResolver(proxy.target());\n        ISynthetixExchangeRates exchangeRates = ISynthetixExchangeRates(resolver.getAddress(_EXCHANGE_RATES_KEY));\n\n        uint256 srcAnswer = srcToken != _ETH ? _getRate(address(srcToken), resolver, exchangeRates) : _getRate(resolver.getAddress(_SETH_KEY), resolver, exchangeRates);\n        uint256 dstAnswer = dstToken != _ETH ? _getRate(address(dstToken), resolver, exchangeRates) : _getRate(resolver.getAddress(_SETH_KEY), resolver, exchangeRates);\n        rate = srcAnswer.mul(1e18).div(dstAnswer);\n        weight = 1e24;\n    }\n\n    function _getRate(address token, ISynthetixAddressResolver resolver, ISynthetixExchangeRates exchangeRates) private view returns(uint256) {\n        string memory symbol = ERC20(token).symbol();\n\n        bytes32 proxyKey;\n        if (_memcmp(bytes(symbol), _SNX)) {\n            proxyKey = _SNX_PROXY_KEY;\n        } else if (_memcmp(bytes(symbol), _SUSD)) {\n            proxyKey = _SUSD_PROXY_KEY;\n        } else {\n            assembly { // solhint-disable-line no-inline-assembly\n                proxyKey := or(_PROXY_KEY, shr(40, mload(add(symbol, 32))))\n            }\n        }\n        require(resolver.getAddress(proxyKey) == token, \"SO: unregistered token\");\n\n        bytes32 key;\n        assembly { // solhint-disable-line no-inline-assembly\n            key := mload(add(symbol, 32))\n        }\n\n        (uint256 answer, bool isInvalid) = exchangeRates.rateAndInvalid(key);\n        require(!isInvalid, \"SO: rate is invalid\");\n\n        return answer;\n    }\n\n    function _memcmp(bytes memory a, bytes memory b) private pure returns(bool) {\n        return (a.length == b.length) && (keccak256(a) == keccak256(b));\n    }\n}\n"
    },
    "contracts/interfaces/ISynthetixExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface ISynthetixExchangeRates {\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint256 rate, bool isInvalid);\n}\n"
    },
    "contracts/interfaces/ISynthetixProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ninterface ISynthetixProxy {\n    function target() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ISynthetixAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface ISynthetixAddressResolver {\n    function getSynth(bytes32 key) external view returns (address);\n    function getAddress(bytes32 key) external view returns (address);\n}\n"
    },
    "contracts/wrappers/FulcrumWrapperLegacy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/ILoanToken.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract FulcrumWrapperLegacy is IWrapper, Ownable {\n    using SafeMath for uint256;\n\n    mapping(IERC20 => IERC20) public iTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToiToken;\n\n    function addMarkets(ILoanToken[] memory markets) external onlyOwner {\n        for (uint256 i = 0; i < markets.length; i++) {\n            IERC20 underlying = IERC20(markets[i].loanTokenAddress());\n            iTokenToToken[IERC20(address(markets[i]))] = underlying;\n            tokenToiToken[underlying] = IERC20(address(markets[i]));\n        }\n    }\n\n    function removeMarkets(ILoanToken[] memory markets) external onlyOwner {\n        for (uint256 i = 0; i < markets.length; i++) {\n            IERC20 underlying = IERC20(markets[i].loanTokenAddress());\n            delete iTokenToToken[IERC20(address(markets[i]))];\n            delete tokenToiToken[underlying];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = iTokenToToken[token];\n        IERC20 iToken = tokenToiToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, uint256(1e36).div(ILoanToken(address(token)).tokenPrice()));\n        } else if (iToken != IERC20(0)) {\n            return (iToken, ILoanToken(address(iToken)).tokenPrice());\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/OffchainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IWrapper.sol\";\nimport \"./MultiWrapper.sol\";\n\ncontract OffchainOracle is Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    enum OracleType { WETH, ETH, WETH_ETH }\n\n    event OracleAdded(IOracle oracle, OracleType oracleType);\n    event OracleRemoved(IOracle oracle, OracleType oracleType);\n    event ConnectorAdded(IERC20 connector);\n    event ConnectorRemoved(IERC20 connector);\n    event MultiWrapperUpdated(MultiWrapper multiWrapper);\n\n    EnumerableSet.AddressSet private _wethOracles;\n    EnumerableSet.AddressSet private _ethOracles;\n    EnumerableSet.AddressSet private _connectors;\n    MultiWrapper public multiWrapper;\n\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _wBase;\n\n    constructor(MultiWrapper _multiWrapper, IOracle[] memory existingOracles, OracleType[] memory oracleTypes, IERC20[] memory existingConnectors, IERC20 wBase) {\n        require(existingOracles.length == oracleTypes.length, \"Arrays length mismatch\");\n        multiWrapper = _multiWrapper;\n        emit MultiWrapperUpdated(_multiWrapper);\n        for (uint256 i = 0; i < existingOracles.length; i++) {\n            if (oracleTypes[i] == OracleType.WETH) {\n                require(_wethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else if (oracleTypes[i] == OracleType.ETH) {\n                require(_ethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else if (oracleTypes[i] == OracleType.WETH_ETH) {\n                require(_wethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n                require(_ethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else {\n                revert(\"Invalid OracleTokenKind\");\n            }\n            emit OracleAdded(existingOracles[i], oracleTypes[i]);\n        }\n        for (uint256 i = 0; i < existingConnectors.length; i++) {\n            require(_connectors.add(address(existingConnectors[i])), \"Connector already added\");\n            emit ConnectorAdded(existingConnectors[i]);\n        }\n        _wBase = wBase;\n    }\n\n    function oracles() public view returns (IOracle[] memory allOracles, OracleType[] memory oracleTypes) {\n        IOracle[] memory oraclesBuffer = new IOracle[](_wethOracles._inner._values.length + _ethOracles._inner._values.length);\n        OracleType[] memory oracleTypesBuffer = new OracleType[](oraclesBuffer.length);\n        for (uint256 i = 0; i < _wethOracles._inner._values.length; i++) {\n            oraclesBuffer[i] = IOracle(uint256(_wethOracles._inner._values[i]));\n            oracleTypesBuffer[i] = OracleType.WETH;\n        }\n\n        uint256 actualItemsCount = _wethOracles._inner._values.length;\n\n        for (uint256 i = 0; i < _ethOracles._inner._values.length; i++) {\n            OracleType kind = OracleType.ETH;\n            uint256 oracleIndex = actualItemsCount;\n            IOracle oracle = IOracle(uint256(_ethOracles._inner._values[i]));\n            for (uint j = 0; j < oraclesBuffer.length; j++) {\n                if (oraclesBuffer[j] == oracle) {\n                    oracleIndex = j;\n                    kind = OracleType.WETH_ETH;\n                    break;\n                }\n            }\n            if (kind == OracleType.ETH) {\n                actualItemsCount++;\n            }\n            oraclesBuffer[oracleIndex] = oracle;\n            oracleTypesBuffer[oracleIndex] = kind;\n        }\n\n        allOracles = new IOracle[](actualItemsCount);\n        oracleTypes = new OracleType[](actualItemsCount);\n        for (uint256 i = 0; i < actualItemsCount; i++) {\n            allOracles[i] = oraclesBuffer[i];\n            oracleTypes[i] = oracleTypesBuffer[i];\n        }\n    }\n\n    function connectors() external view returns (IERC20[] memory allConnectors) {\n        allConnectors = new IERC20[](_connectors.length());\n        for (uint256 i = 0; i < allConnectors.length; i++) {\n            allConnectors[i] = IERC20(uint256(_connectors._inner._values[i]));\n        }\n    }\n\n    function setMultiWrapper(MultiWrapper _multiWrapper) external onlyOwner {\n        multiWrapper = _multiWrapper;\n        emit MultiWrapperUpdated(_multiWrapper);\n    }\n\n    function addOracle(IOracle oracle, OracleType oracleKind) external onlyOwner {\n        if (oracleKind == OracleType.WETH) {\n            require(_wethOracles.add(address(oracle)), \"Oracle already added\");\n        } else if (oracleKind == OracleType.ETH) {\n            require(_ethOracles.add(address(oracle)), \"Oracle already added\");\n        } else if (oracleKind == OracleType.WETH_ETH) {\n            require(_wethOracles.add(address(oracle)), \"Oracle already added\");\n            require(_ethOracles.add(address(oracle)), \"Oracle already added\");\n        } else {\n            revert(\"Invalid OracleTokenKind\");\n        }\n        emit OracleAdded(oracle, oracleKind);\n    }\n\n    function removeOracle(IOracle oracle, OracleType oracleKind) external onlyOwner {\n        if (oracleKind == OracleType.WETH) {\n            require(_wethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else if (oracleKind == OracleType.ETH) {\n            require(_ethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else if (oracleKind == OracleType.WETH_ETH) {\n            require(_wethOracles.remove(address(oracle)), \"Unknown oracle\");\n            require(_ethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else {\n            revert(\"Invalid OracleTokenKind\");\n        }\n        emit OracleRemoved(oracle, oracleKind);\n    }\n\n    function addConnector(IERC20 connector) external onlyOwner {\n        require(_connectors.add(address(connector)), \"Connector already added\");\n        emit ConnectorAdded(connector);\n    }\n\n    function removeConnector(IERC20 connector) external onlyOwner {\n        require(_connectors.remove(address(connector)), \"Unknown connector\");\n        emit ConnectorRemoved(connector);\n    }\n\n    /*\n        WARNING!\n        Usage of the dex oracle on chain is highly discouraged!\n        getRate function can be easily manipulated inside transaction!\n    */\n    function getRate(IERC20 srcToken, IERC20 dstToken, bool useWrappers) external view returns (uint256 weightedRate) {\n        require(srcToken != dstToken, \"Tokens should not be the same\");\n        uint256 totalWeight;\n        (IOracle[] memory allOracles, ) = oracles();\n        (IERC20[] memory wrappedSrcTokens, uint256[] memory srcRates) = _getWrappedTokens(srcToken, useWrappers);\n        (IERC20[] memory wrappedDstTokens, uint256[] memory dstRates) = _getWrappedTokens(dstToken, useWrappers);\n        bytes32[] memory connectors_ = _connectors._inner._values;\n\n        for (uint256 k1 = 0; k1 < wrappedSrcTokens.length; k1++) {\n            for (uint256 k2 = 0; k2 < wrappedDstTokens.length; k2++) {\n                if (wrappedSrcTokens[k1] == wrappedDstTokens[k2]) {\n                    return srcRates[k1].mul(dstRates[k2]).div(1e18);\n                }\n                for (uint256 j = 0; j < connectors_.length; j++) {\n                    if (IERC20(uint256(connectors_[j])) == wrappedSrcTokens[k1] || IERC20(uint256(connectors_[j])) == wrappedDstTokens[k2]) {\n                        continue;\n                    }\n                    for (uint256 i = 0; i < allOracles.length; i++) {\n                        try allOracles[i].getRate(wrappedSrcTokens[k1], wrappedDstTokens[k2], IERC20(uint256(connectors_[j]))) returns (uint256 rate, uint256 weight) {\n                            rate = rate.mul(srcRates[k1]).mul(dstRates[k2]).div(1e36);\n                            weight = weight.mul(weight);\n                            weightedRate = weightedRate.add(rate.mul(weight));\n                            totalWeight = totalWeight.add(weight);\n                        } catch {}  // solhint-disable-line no-empty-blocks\n                    }\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            weightedRate = weightedRate.div(totalWeight);\n        }\n    }\n\n    /// @dev Same as `getRate` but checks against `ETH` and `WETH` only\n    function getRateToEth(IERC20 srcToken, bool useSrcWrappers) external view returns (uint256 weightedRate) {\n        uint256 totalWeight;\n        (IERC20[] memory wrappedSrcTokens, uint256[] memory srcRates) = _getWrappedTokens(srcToken, useSrcWrappers);\n        IERC20[2] memory wrappedDstTokens = [_BASE, _wBase];\n        bytes32[][2] memory wrappedOracles = [_ethOracles._inner._values, _wethOracles._inner._values];\n        bytes32[] memory connectors_ = _connectors._inner._values;\n\n        for (uint256 k1 = 0; k1 < wrappedSrcTokens.length; k1++) {\n            for (uint256 k2 = 0; k2 < wrappedDstTokens.length; k2++) {\n                if (wrappedSrcTokens[k1] == wrappedDstTokens[k2]) {\n                    return srcRates[k1];\n                }\n                for (uint256 j = 0; j < connectors_.length; j++) {\n                    IERC20 connector = IERC20(uint256(connectors_[j]));\n                    if (connector == wrappedSrcTokens[k1] || connector == wrappedDstTokens[k2]) {\n                        continue;\n                    }\n                    for (uint256 i = 0; i < wrappedOracles[k2].length; i++) {\n                        try IOracle(uint256(wrappedOracles[k2][i])).getRate(wrappedSrcTokens[k1], wrappedDstTokens[k2], connector) returns (uint256 rate, uint256 weight) {\n                            rate = rate.mul(srcRates[k1]).div(1e18);\n                            weight = weight.mul(weight);\n                            weightedRate = weightedRate.add(rate.mul(weight));\n                            totalWeight = totalWeight.add(weight);\n                        } catch {}  // solhint-disable-line no-empty-blocks\n                    }\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            weightedRate = weightedRate.div(totalWeight);\n        }\n    }\n\n    function _getWrappedTokens(IERC20 token, bool useWrappers) internal view returns (IERC20[] memory wrappedTokens, uint256[] memory rates) {\n        if (useWrappers) {\n            return multiWrapper.getWrappedTokens(token);\n        }\n\n        wrappedTokens = new IERC20[](1);\n        wrappedTokens[0] = token;\n        rates = new uint256[](1);\n        rates[0] = uint256(1e18);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/MultiWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IWrapper.sol\";\n\n\ncontract MultiWrapper is Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event WrapperAdded(IWrapper connector);\n    event WrapperRemoved(IWrapper connector);\n\n    EnumerableSet.AddressSet private _wrappers;\n\n    constructor(IWrapper[] memory existingWrappers) {\n        for (uint256 i = 0; i < existingWrappers.length; i++) {\n            require(_wrappers.add(address(existingWrappers[i])), \"Wrapper already added\");\n            emit WrapperAdded(existingWrappers[i]);\n        }\n    }\n\n    function wrappers() external view returns (IWrapper[] memory allWrappers) {\n        allWrappers = new IWrapper[](_wrappers.length());\n        for (uint256 i = 0; i < allWrappers.length; i++) {\n            allWrappers[i] = IWrapper(uint256(_wrappers._inner._values[i]));\n        }\n    }\n\n    function addWrapper(IWrapper wrapper) external onlyOwner {\n        require(_wrappers.add(address(wrapper)), \"Wrapper already added\");\n        emit WrapperAdded(wrapper);\n    }\n\n    function removeWrapper(IWrapper wrapper) external onlyOwner {\n        require(_wrappers.remove(address(wrapper)), \"Unknown wrapper\");\n        emit WrapperRemoved(wrapper);\n    }\n\n    function getWrappedTokens(IERC20 token) external view returns (IERC20[] memory wrappedTokens, uint256[] memory rates) {\n        IERC20[] memory memWrappedTokens = new IERC20[](20);\n        uint256[] memory memRates = new uint256[](20);\n        uint256 len = 0;\n        for (uint256 i = 0; i < _wrappers._inner._values.length; i++) {\n            try IWrapper(uint256(_wrappers._inner._values[i])).wrap(token) returns (IERC20 wrappedToken, uint256 rate) {\n                memWrappedTokens[len] = wrappedToken;\n                memRates[len] = rate;\n                len += 1;\n                for (uint256 j = 0; j < _wrappers._inner._values.length; j++) {\n                    if (i != j) {\n                        try IWrapper(uint256(_wrappers._inner._values[j])).wrap(wrappedToken) returns (IERC20 wrappedToken2, uint256 rate2) {\n                            bool used = false;\n                            for (uint256 k = 0; k < len; k++) {\n                                if (wrappedToken2 == memWrappedTokens[k]) {\n                                    used = true;\n                                    break;\n                                }\n                            }\n                            if (!used) {\n                                memWrappedTokens[len] = wrappedToken2;\n                                memRates[len] = rate.mul(rate2).div(1e18);\n                                len += 1;\n                            }\n                        } catch { continue; }\n                    }\n                }\n            } catch { continue; }\n        }\n        wrappedTokens = new IERC20[](len + 1);\n        rates = new uint256[](len + 1);\n        for (uint256 i = 0; i < len; i++) {\n            wrappedTokens[i] = memWrappedTokens[i];\n            rates[i] = memRates[i];\n        }\n        wrappedTokens[len] = token;\n        rates[len] = 1e18;\n    }\n}\n"
    },
    "contracts/wrappers/CompoundLikeWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract CompoundLikeWrapper is IWrapper {\n    using SafeMath for uint256;\n\n    IComptroller private immutable _comptroller;\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _cBase;\n\n    mapping(IERC20 => IERC20) public cTokenToToken;\n    mapping(IERC20 => IERC20) public tokenTocToken;\n\n    constructor(IComptroller comptroller, IERC20 cBase) {\n        _comptroller = comptroller;\n        _cBase = cBase;\n    }\n\n    function addMarkets(ICToken[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            (bool isListed, , ) = _comptroller.markets(markets[i]);\n            require(isListed, \"Market is not listed\");\n            IERC20 underlying = markets[i].underlying();\n            cTokenToToken[markets[i]] = underlying;\n            tokenTocToken[underlying] = markets[i];\n        }\n    }\n\n    function removeMarkets(ICToken[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            (bool isListed, , ) = _comptroller.markets(markets[i]);\n            require(!isListed, \"Market is listed\");\n            IERC20 underlying = markets[i].underlying();\n            delete cTokenToToken[markets[i]];\n            delete tokenTocToken[underlying];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        if (token == _BASE) {\n            return (_cBase, uint256(1e36).div(ICToken(address(_cBase)).exchangeRateStored()));\n        } else if (token == _cBase) {\n            return (_BASE, ICToken(address(_cBase)).exchangeRateStored());\n        }\n        IERC20 underlying = cTokenToToken[token];\n        IERC20 cToken = tokenTocToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, ICToken(address(token)).exchangeRateStored());\n        } else if (cToken != IERC20(0)) {\n            return (cToken, uint256(1e36).div(ICToken(address(cToken)).exchangeRateStored()));\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"./ICToken.sol\";\n\n\ninterface IComptroller {\n    function getAllMarkets() external view returns (ICToken[] memory);\n    function markets(ICToken market) external view returns (bool isListed, uint256 collateralFactorMantissa, bool isComped);\n}\n"
    },
    "contracts/interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ICToken is IERC20 {\n    function underlying() external view returns (IERC20 token);\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\n}\n"
    },
    "contracts/oracles/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IChainlink.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ncontract ChainlinkOracle is IOracle {\n    using SafeMath for uint256;\n\n    IChainlink public immutable chainlink;\n    address private constant _QUOTE = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private constant _NONE = IERC20(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n    uint256 private constant _RATE_TTL = 1 days;\n\n    constructor(IChainlink _chainlink) {\n        chainlink = _chainlink;\n    }\n\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view override returns (uint256 rate, uint256 weight) {\n        require(connector == _NONE, \"CO: connector should be None\");\n        uint256 srcAnswer = srcToken != _ETH ? _getRate(srcToken) : 1e18;\n        uint256 dstAnswer = dstToken != _ETH ? _getRate(dstToken) : 1e18;\n        rate = srcAnswer.mul(1e18).div(dstAnswer);\n        weight = 1e24;\n    }\n\n    function _getRate(IERC20 token) private view returns (uint256 rate) {\n        (, int256 answer, , uint256 srcUpdatedAt, ) = chainlink.latestRoundData(token, _QUOTE);\n        require(block.timestamp < srcUpdatedAt + _RATE_TTL, \"CO: rate too old\");\n        rate = uint256(answer);\n        uint8 decimals = ERC20(address(token)).decimals();\n        rate = rate * (10 ** (uint256(18).sub(decimals)));\n    }\n}\n"
    },
    "contracts/interfaces/IChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IChainlink {\n    /**\n * @notice get data about the latest round. Consumers are encouraged to check\n * that they're receiving fresh data by inspecting the updatedAt and\n * answeredInRound return values.\n * Note that different underlying implementations of AggregatorV3Interface\n * have slightly different semantics for some of the return values. Consumers\n * should determine what implementations they expect to receive\n * data from and validate that they can properly handle return data from all\n * of them.\n * @param base base asset address\n * @param quote quote asset address\n * @return roundId is the round ID from the aggregator for which the data was\n * retrieved combined with a phase to ensure that round IDs get larger as\n * time moves forward.\n * @return answer is the answer for the given round\n * @return startedAt is the timestamp when the round was started.\n * (Only some AggregatorV3Interface implementations return meaningful values)\n * @return updatedAt is the timestamp when the round last was updated (i.e.\n * answer was last computed)\n * @return answeredInRound is the round ID of the round in which the answer\n * was computed.\n * (Only some AggregatorV3Interface implementations return meaningful values)\n * @dev Note that answer and updatedAt may change between queries.\n */\n    function latestRoundData(\n        IERC20 base,\n        address quote\n    )\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/oracles/MooniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IMooniswapFactory.sol\";\nimport \"./OracleBase.sol\";\n\n\ncontract MooniswapOracle is OracleBase {\n    IMooniswapFactory public immutable factory;\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n\n    constructor(IMooniswapFactory _factory) {\n        factory = _factory;\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256, uint256) {\n        IMooniswap mooniswap = factory.pools(srcToken, dstToken);\n        IERC20[] memory tokens = mooniswap.getTokens();\n        uint256[2] memory balances;\n        for (uint256 i = 0; i < 2; ++i) {\n            if (tokens[i] == _ETH) {\n                balances[i] = address(mooniswap).balance;\n            } else {\n                balances[i] = tokens[i].balanceOf(address(mooniswap));\n            }\n        }\n        if (tokens[0] == srcToken) {\n            return (balances[0], balances[1]);\n        } else {\n            return (balances[1], balances[0]);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./IMooniswap.sol\";\n\ninterface IMooniswapFactory {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n}\n"
    },
    "contracts/interfaces/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IMooniswap {\n    function getTokens() external view returns(IERC20[] memory tokens);\n}\n"
    },
    "contracts/interfaces/IOffchainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IOffchainOracle {\n    function getRate(IERC20 srcToken, IERC20 dstToken) external view returns (uint256 weightedRate);\n}\n"
    },
    "contracts/interfaces/ILendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma abicoder v2;  // solhint-disable-line compiler-version\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ILendingPoolV2 {\n    struct ReserveConfigurationMap {\n        uint256 data;\n    }\n\n    struct ReserveData {\n        ReserveConfigurationMap configuration;\n        uint128 liquidityIndex;\n        uint128 variableBorrowIndex;\n        uint128 currentLiquidityRate;\n        uint128 currentVariableBorrowRate;\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        address interestRateStrategyAddress;\n        uint8 id;\n    }\n\n    function getReserveData(address asset) external view returns (ReserveData memory);\n}\n"
    },
    "contracts/wrappers/AaveWrapperV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;  // solhint-disable-line compiler-version\n\nimport \"../interfaces/ILendingPoolV2.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract AaveWrapperV2 is IWrapper {\n    // solhint-disable-next-line var-name-mixedcase\n    ILendingPoolV2 private immutable _LENDING_POOL;\n\n    mapping(IERC20 => IERC20) public aTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToaToken;\n\n    constructor(ILendingPoolV2 lendingPool) {\n        _LENDING_POOL = lendingPool;\n    }\n\n    function addMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ILendingPoolV2.ReserveData memory reserveData = _LENDING_POOL.getReserveData(address(tokens[i]));\n            IERC20 aToken = IERC20(reserveData.aTokenAddress);\n            require(aToken != IERC20(0), \"Token is not supported\");\n            aTokenToToken[aToken] = tokens[i];\n            tokenToaToken[tokens[i]] = aToken;\n        }\n    }\n\n    function removeMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ILendingPoolV2.ReserveData memory reserveData = _LENDING_POOL.getReserveData(address(tokens[i]));\n            IERC20 aToken = IERC20(reserveData.aTokenAddress);\n            require(aToken == IERC20(0), \"Token is still supported\");\n            delete aTokenToToken[aToken];\n            delete tokenToaToken[tokens[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = aTokenToToken[token];\n        IERC20 aToken = tokenToaToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, 1e18);\n        } else if (aToken != IERC20(0)) {\n            return (aToken, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILendingPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ILendingPoolV1 {\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            IERC20 aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}\n"
    },
    "contracts/wrappers/AaveWrapperV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/ILendingPoolV1.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract AaveWrapperV1 is IWrapper {\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private constant _EEE = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    ILendingPoolV1 private constant _LENDING_POOL = ILendingPoolV1(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    mapping(IERC20 => IERC20) public aTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToaToken;\n\n    function addMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            (,,,,,,,,,,, IERC20 aToken,) = _LENDING_POOL.getReserveData(address(tokens[i]));\n            require(aToken != IERC20(0), \"Token is not supported\");\n            aTokenToToken[aToken] = tokens[i];\n            tokenToaToken[tokens[i]] = aToken;\n        }\n    }\n\n    function removeMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            (,,,,,,,,,,, IERC20 aToken,) = _LENDING_POOL.getReserveData(address(tokens[i]));\n            require(aToken == IERC20(0), \"Token is still supported\");\n            delete aTokenToToken[aToken];\n            delete tokenToaToken[tokens[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        token = token == _ETH ? _EEE : token;\n        IERC20 underlying = aTokenToToken[token];\n        IERC20 aToken = tokenToaToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying == _EEE ? _ETH : underlying, 1e18);\n        } else if (aToken != IERC20(0)) {\n            return (aToken, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/wrappers/BaseCoinWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract BaseCoinWrapper is IWrapper {\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _wBase;\n\n    constructor(IERC20 wBase) {\n        _wBase = wBase;\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        if(token == _BASE) {\n            return (_wBase, 1e18);\n        } else if (token == _wBase) {\n            return (_BASE, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}