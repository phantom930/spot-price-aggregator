{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IBzxProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n\ninterface IBzxProtocol {\n    function underlyingToLoanPool(address underlying) external view returns (address loanPool);\n}\n"
    },
    "contracts/wrappers/FulcrumWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/ILoanToken.sol\";\nimport \"../interfaces/IBzxProtocol.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract FulcrumWrapper is IWrapper {\n    using SafeMath for uint256;\n\n    IBzxProtocol private constant _BZX_PROTOCOL = IBzxProtocol(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n\n    mapping(IERC20 => IERC20) public iTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToiToken;\n\n    function addMarkets(IERC20[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            address loanPool = _BZX_PROTOCOL.underlyingToLoanPool(address(markets[i]));\n            require(loanPool != address(0), \"Token is not supported\");\n            iTokenToToken[IERC20(loanPool)] = markets[i];\n            tokenToiToken[markets[i]] = IERC20(loanPool);\n        }\n    }\n\n    function removeMarkets(IERC20[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            address loanPool = _BZX_PROTOCOL.underlyingToLoanPool(address(markets[i]));\n            require(loanPool == address(0), \"Token is still supported\");\n            delete iTokenToToken[IERC20(loanPool)];\n            delete tokenToiToken[markets[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = iTokenToToken[token];\n        IERC20 iToken = tokenToiToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, uint256(1e36).div(ILoanToken(address(token)).tokenPrice()));\n        } else if (iToken != IERC20(0)) {\n            return (iToken, ILoanToken(address(iToken)).tokenPrice());\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/ILoanToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n\ninterface ILoanToken {\n    function tokenPrice() external view returns (uint256 price);\n    function loanTokenAddress() external view returns (address underlying);\n}\n"
    },
    "contracts/interfaces/IWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IWrapper {\n    function wrap(IERC20 token) external view returns (IERC20 wrappedToken, uint256 rate);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/wrappers/FulcrumWrapperLegacy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/ILoanToken.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract FulcrumWrapperLegacy is IWrapper, Ownable {\n    using SafeMath for uint256;\n\n    mapping(IERC20 => IERC20) public iTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToiToken;\n\n    function addMarkets(ILoanToken[] memory markets) external onlyOwner {\n        for (uint256 i = 0; i < markets.length; i++) {\n            IERC20 underlying = IERC20(markets[i].loanTokenAddress());\n            iTokenToToken[IERC20(address(markets[i]))] = underlying;\n            tokenToiToken[underlying] = IERC20(address(markets[i]));\n        }\n    }\n\n    function removeMarkets(ILoanToken[] memory markets) external onlyOwner {\n        for (uint256 i = 0; i < markets.length; i++) {\n            IERC20 underlying = IERC20(markets[i].loanTokenAddress());\n            delete iTokenToToken[IERC20(address(markets[i]))];\n            delete tokenToiToken[underlying];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = iTokenToToken[token];\n        IERC20 iToken = tokenToiToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, uint256(1e36).div(ILoanToken(address(token)).tokenPrice()));\n        } else if (iToken != IERC20(0)) {\n            return (iToken, ILoanToken(address(iToken)).tokenPrice());\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/wrappers/CompoundLikeWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract CompoundLikeWrapper is IWrapper {\n    using SafeMath for uint256;\n\n    IComptroller private immutable _comptroller;\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _cBase;\n\n    mapping(IERC20 => IERC20) public cTokenToToken;\n    mapping(IERC20 => IERC20) public tokenTocToken;\n\n    constructor(IComptroller comptroller, IERC20 cBase) {\n        _comptroller = comptroller;\n        _cBase = cBase;\n    }\n\n    function addMarkets(ICToken[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            (bool isListed, , ) = _comptroller.markets(markets[i]);\n            require(isListed, \"Market is not listed\");\n            IERC20 underlying = markets[i].underlying();\n            cTokenToToken[markets[i]] = underlying;\n            tokenTocToken[underlying] = markets[i];\n        }\n    }\n\n    function removeMarkets(ICToken[] memory markets) external {\n        for (uint256 i = 0; i < markets.length; i++) {\n            (bool isListed, , ) = _comptroller.markets(markets[i]);\n            require(!isListed, \"Market is listed\");\n            IERC20 underlying = markets[i].underlying();\n            delete cTokenToToken[markets[i]];\n            delete tokenTocToken[underlying];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        if (token == _BASE) {\n            return (_cBase, uint256(1e36).div(ICToken(address(_cBase)).exchangeRateStored()));\n        } else if (token == _cBase) {\n            return (_BASE, ICToken(address(_cBase)).exchangeRateStored());\n        }\n        IERC20 underlying = cTokenToToken[token];\n        IERC20 cToken = tokenTocToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, ICToken(address(token)).exchangeRateStored());\n        } else if (cToken != IERC20(0)) {\n            return (cToken, uint256(1e36).div(ICToken(address(cToken)).exchangeRateStored()));\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"./ICToken.sol\";\n\n\ninterface IComptroller {\n    function getAllMarkets() external view returns (ICToken[] memory);\n    function markets(ICToken market) external view returns (bool isListed, uint256 collateralFactorMantissa, bool isComped);\n}\n"
    },
    "contracts/interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ICToken is IERC20 {\n    function underlying() external view returns (IERC20 token);\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\n}\n"
    },
    "contracts/oracles/OracleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../libraries/Sqrt.sol\";\n\n\nabstract contract OracleBase is IOracle {\n    using SafeMath for uint256;\n    using Sqrt for uint256;\n\n    IERC20 private constant _NONE = IERC20(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view override returns (uint256 rate, uint256 weight) {\n        uint256 balance0;\n        uint256 balance1;\n        if (connector == _NONE) {\n            (balance0, balance1) = _getBalances(srcToken, dstToken);\n        } else {\n            uint256 balanceConnector0;\n            uint256 balanceConnector1;\n            (balance0, balanceConnector0) = _getBalances(srcToken, connector);\n            (balanceConnector1, balance1) = _getBalances(connector, dstToken);\n            if (balanceConnector0 > balanceConnector1) {\n                balance0 = balance0.mul(balanceConnector1).div(balanceConnector0);\n            } else {\n                balance1 = balance1.mul(balanceConnector0).div(balanceConnector1);\n            }\n        }\n\n        rate = balance1.mul(1e18).div(balance0);\n        weight = balance0.mul(balance1).sqrt();\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view virtual returns (uint256 srcBalance, uint256 dstBalance);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IOracle {\n    function getRate(IERC20 srcToken, IERC20 dstToken, IERC20 connector) external view returns (uint256 rate, uint256 weight);\n}\n"
    },
    "contracts/libraries/Sqrt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n\nlibrary Sqrt {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/oracles/UniswapV2LikeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./OracleBase.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\n\n\ncontract UniswapV2LikeOracle is OracleBase {\n    address public immutable factory;\n    bytes32 public immutable initcodeHash;\n\n    constructor(address _factory, bytes32 _initcodeHash) {\n        factory = _factory;\n        initcodeHash = _initcodeHash;\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function _pairFor(IERC20 tokenA, IERC20 tokenB) private view returns (address pair) {\n        pair = address(uint256(keccak256(abi.encodePacked(\n                hex\"ff\",\n                factory,\n                keccak256(abi.encodePacked(tokenA, tokenB)),\n                initcodeHash\n            ))));\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256 srcBalance, uint256 dstBalance) {\n        (IERC20 token0, IERC20 token1) = srcToken < dstToken ? (srcToken, dstToken) : (dstToken, srcToken);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairFor(token0, token1)).getReserves();\n        (srcBalance, dstBalance) = srcToken == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\n\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n}\n"
    },
    "contracts/oracles/UniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IUniswapFactory.sol\";\nimport \"./OracleBase.sol\";\n\n\ncontract UniswapOracle is OracleBase {\n    IUniswapFactory private immutable _UNISWAP_FACTORY;  // solhint-disable-line var-name-mixedcase\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n\n    constructor(IUniswapFactory factory) {\n        _UNISWAP_FACTORY = factory;\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256 srcBalance, uint256 dstBalance) {\n        if (srcToken == _ETH) {\n            address exchange = _UNISWAP_FACTORY.getExchange(dstToken);\n            require(exchange != address(0), \"Pool does not exist\");\n            srcBalance = exchange.balance;\n            dstBalance = dstToken.balanceOf(exchange);\n        } else if (dstToken == _ETH) {\n            address exchange = _UNISWAP_FACTORY.getExchange(srcToken);\n            require(exchange != address(0), \"Pool does not exist\");\n            srcBalance = srcToken.balanceOf(exchange);\n            dstBalance = exchange.balance;\n        } else {\n            revert(\"Unsupported tokens\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IUniswapFactory {\n    function getExchange(IERC20 token) external view returns (address exchange);\n}\n"
    },
    "contracts/OffchainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IWrapper.sol\";\nimport \"./MultiWrapper.sol\";\n\ncontract OffchainOracle is Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    enum OracleType { WETH, ETH, WETH_ETH }\n\n    event OracleAdded(IOracle oracle, OracleType oracleType);\n    event OracleRemoved(IOracle oracle, OracleType oracleType);\n    event ConnectorAdded(IERC20 connector);\n    event ConnectorRemoved(IERC20 connector);\n    event MultiWrapperUpdated(MultiWrapper multiWrapper);\n\n    EnumerableSet.AddressSet private _wethOracles;\n    EnumerableSet.AddressSet private _ethOracles;\n    EnumerableSet.AddressSet private _connectors;\n    MultiWrapper public multiWrapper;\n\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _wBase;\n\n    constructor(MultiWrapper _multiWrapper, IOracle[] memory existingOracles, OracleType[] memory oracleTypes, IERC20[] memory existingConnectors, IERC20 wBase) {\n        require(existingOracles.length == oracleTypes.length, \"Arrays length mismatch\");\n        multiWrapper = _multiWrapper;\n        emit MultiWrapperUpdated(_multiWrapper);\n        for (uint256 i = 0; i < existingOracles.length; i++) {\n            if (oracleTypes[i] == OracleType.WETH) {\n                require(_wethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else if (oracleTypes[i] == OracleType.ETH) {\n                require(_ethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else if (oracleTypes[i] == OracleType.WETH_ETH) {\n                require(_wethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n                require(_ethOracles.add(address(existingOracles[i])), \"Oracle already added\");\n            } else {\n                revert(\"Invalid OracleTokenKind\");\n            }\n            emit OracleAdded(existingOracles[i], oracleTypes[i]);\n        }\n        for (uint256 i = 0; i < existingConnectors.length; i++) {\n            require(_connectors.add(address(existingConnectors[i])), \"Connector already added\");\n            emit ConnectorAdded(existingConnectors[i]);\n        }\n        _wBase = wBase;\n    }\n\n    function oracles() public view returns (IOracle[] memory allOracles, OracleType[] memory oracleTypes) {\n        IOracle[] memory oraclesBuffer = new IOracle[](_wethOracles._inner._values.length + _ethOracles._inner._values.length);\n        OracleType[] memory oracleTypesBuffer = new OracleType[](oraclesBuffer.length);\n        for (uint256 i = 0; i < _wethOracles._inner._values.length; i++) {\n            oraclesBuffer[i] = IOracle(uint256(_wethOracles._inner._values[i]));\n            oracleTypesBuffer[i] = OracleType.WETH;\n        }\n\n        uint256 actualItemsCount = _wethOracles._inner._values.length;\n\n        for (uint256 i = 0; i < _ethOracles._inner._values.length; i++) {\n            OracleType kind = OracleType.ETH;\n            uint256 oracleIndex = actualItemsCount;\n            IOracle oracle = IOracle(uint256(_ethOracles._inner._values[i]));\n            for (uint j = 0; j < oraclesBuffer.length; j++) {\n                if (oraclesBuffer[j] == oracle) {\n                    oracleIndex = j;\n                    kind = OracleType.WETH_ETH;\n                    break;\n                }\n            }\n            if (kind == OracleType.ETH) {\n                actualItemsCount++;\n            }\n            oraclesBuffer[oracleIndex] = oracle;\n            oracleTypesBuffer[oracleIndex] = kind;\n        }\n\n        allOracles = new IOracle[](actualItemsCount);\n        oracleTypes = new OracleType[](actualItemsCount);\n        for (uint256 i = 0; i < actualItemsCount; i++) {\n            allOracles[i] = oraclesBuffer[i];\n            oracleTypes[i] = oracleTypesBuffer[i];\n        }\n    }\n\n    function connectors() external view returns (IERC20[] memory allConnectors) {\n        allConnectors = new IERC20[](_connectors.length());\n        for (uint256 i = 0; i < allConnectors.length; i++) {\n            allConnectors[i] = IERC20(uint256(_connectors._inner._values[i]));\n        }\n    }\n\n    function setMultiWrapper(MultiWrapper _multiWrapper) external onlyOwner {\n        multiWrapper = _multiWrapper;\n        emit MultiWrapperUpdated(_multiWrapper);\n    }\n\n    function addOracle(IOracle oracle, OracleType oracleKind) external onlyOwner {\n        if (oracleKind == OracleType.WETH) {\n            require(_wethOracles.add(address(oracle)), \"Oracle already added\");\n        } else if (oracleKind == OracleType.ETH) {\n            require(_ethOracles.add(address(oracle)), \"Oracle already added\");\n        } else if (oracleKind == OracleType.WETH_ETH) {\n            require(_wethOracles.add(address(oracle)), \"Oracle already added\");\n            require(_ethOracles.add(address(oracle)), \"Oracle already added\");\n        } else {\n            revert(\"Invalid OracleTokenKind\");\n        }\n        emit OracleAdded(oracle, oracleKind);\n    }\n\n    function removeOracle(IOracle oracle, OracleType oracleKind) external onlyOwner {\n        if (oracleKind == OracleType.WETH) {\n            require(_wethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else if (oracleKind == OracleType.ETH) {\n            require(_ethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else if (oracleKind == OracleType.WETH_ETH) {\n            require(_wethOracles.remove(address(oracle)), \"Unknown oracle\");\n            require(_ethOracles.remove(address(oracle)), \"Unknown oracle\");\n        } else {\n            revert(\"Invalid OracleTokenKind\");\n        }\n        emit OracleRemoved(oracle, oracleKind);\n    }\n\n    function addConnector(IERC20 connector) external onlyOwner {\n        require(_connectors.add(address(connector)), \"Connector already added\");\n        emit ConnectorAdded(connector);\n    }\n\n    function removeConnector(IERC20 connector) external onlyOwner {\n        require(_connectors.remove(address(connector)), \"Unknown connector\");\n        emit ConnectorRemoved(connector);\n    }\n\n    /*\n        WARNING!\n        Usage of the dex oracle on chain is highly discouraged!\n        getRate function can be easily manipulated inside transaction!\n    */\n    function getRate(IERC20 srcToken, IERC20 dstToken, bool useWrappers) external view returns (uint256 weightedRate) {\n        require(srcToken != dstToken, \"Tokens should not be the same\");\n        uint256 totalWeight;\n        (IOracle[] memory allOracles, ) = oracles();\n        (IERC20[] memory wrappedSrcTokens, uint256[] memory srcRates) = _getWrappedTokens(srcToken, useWrappers);\n        (IERC20[] memory wrappedDstTokens, uint256[] memory dstRates) = _getWrappedTokens(dstToken, useWrappers);\n        bytes32[] memory connectors_ = _connectors._inner._values;\n\n        for (uint256 k1 = 0; k1 < wrappedSrcTokens.length; k1++) {\n            for (uint256 k2 = 0; k2 < wrappedDstTokens.length; k2++) {\n                if (wrappedSrcTokens[k1] == wrappedDstTokens[k2]) {\n                    return srcRates[k1].mul(dstRates[k2]).div(1e18);\n                }\n                for (uint256 j = 0; j < connectors_.length; j++) {\n                    if (IERC20(uint256(connectors_[j])) == wrappedSrcTokens[k1] || IERC20(uint256(connectors_[j])) == wrappedDstTokens[k2]) {\n                        continue;\n                    }\n                    for (uint256 i = 0; i < allOracles.length; i++) {\n                        try allOracles[i].getRate(wrappedSrcTokens[k1], wrappedDstTokens[k2], IERC20(uint256(connectors_[j]))) returns (uint256 rate, uint256 weight) {\n                            rate = rate.mul(srcRates[k1]).mul(dstRates[k2]).div(1e36);\n                            weight = weight.mul(weight);\n                            weightedRate = weightedRate.add(rate.mul(weight));\n                            totalWeight = totalWeight.add(weight);\n                        } catch {}  // solhint-disable-line no-empty-blocks\n                    }\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            weightedRate = weightedRate.div(totalWeight);\n        }\n    }\n\n    /// @dev Same as `getRate` but checks against `ETH` and `WETH` only\n    function getRateToEth(IERC20 srcToken, bool useSrcWrappers) external view returns (uint256 weightedRate) {\n        uint256 totalWeight;\n        (IERC20[] memory wrappedSrcTokens, uint256[] memory srcRates) = _getWrappedTokens(srcToken, useSrcWrappers);\n        IERC20[2] memory wrappedDstTokens = [_BASE, _wBase];\n        bytes32[][2] memory wrappedOracles = [_ethOracles._inner._values, _wethOracles._inner._values];\n        bytes32[] memory connectors_ = _connectors._inner._values;\n\n        for (uint256 k1 = 0; k1 < wrappedSrcTokens.length; k1++) {\n            for (uint256 k2 = 0; k2 < wrappedDstTokens.length; k2++) {\n                if (wrappedSrcTokens[k1] == wrappedDstTokens[k2]) {\n                    return srcRates[k1];\n                }\n                for (uint256 j = 0; j < connectors_.length; j++) {\n                    IERC20 connector = IERC20(uint256(connectors_[j]));\n                    if (connector == wrappedSrcTokens[k1] || connector == wrappedDstTokens[k2]) {\n                        continue;\n                    }\n                    for (uint256 i = 0; i < wrappedOracles[k2].length; i++) {\n                        try IOracle(uint256(wrappedOracles[k2][i])).getRate(wrappedSrcTokens[k1], wrappedDstTokens[k2], connector) returns (uint256 rate, uint256 weight) {\n                            rate = rate.mul(srcRates[k1]).div(1e18);\n                            weight = weight.mul(weight);\n                            weightedRate = weightedRate.add(rate.mul(weight));\n                            totalWeight = totalWeight.add(weight);\n                        } catch {}  // solhint-disable-line no-empty-blocks\n                    }\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            weightedRate = weightedRate.div(totalWeight);\n        }\n    }\n\n    function _getWrappedTokens(IERC20 token, bool useWrappers) internal view returns (IERC20[] memory wrappedTokens, uint256[] memory rates) {\n        if (useWrappers) {\n            return multiWrapper.getWrappedTokens(token);\n        }\n\n        wrappedTokens = new IERC20[](1);\n        wrappedTokens[0] = token;\n        rates = new uint256[](1);\n        rates[0] = uint256(1e18);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/MultiWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IWrapper.sol\";\n\n\ncontract MultiWrapper is Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event WrapperAdded(IWrapper connector);\n    event WrapperRemoved(IWrapper connector);\n\n    EnumerableSet.AddressSet private _wrappers;\n\n    constructor(IWrapper[] memory existingWrappers) {\n        for (uint256 i = 0; i < existingWrappers.length; i++) {\n            require(_wrappers.add(address(existingWrappers[i])), \"Wrapper already added\");\n            emit WrapperAdded(existingWrappers[i]);\n        }\n    }\n\n    function wrappers() external view returns (IWrapper[] memory allWrappers) {\n        allWrappers = new IWrapper[](_wrappers.length());\n        for (uint256 i = 0; i < allWrappers.length; i++) {\n            allWrappers[i] = IWrapper(uint256(_wrappers._inner._values[i]));\n        }\n    }\n\n    function addWrapper(IWrapper wrapper) external onlyOwner {\n        require(_wrappers.add(address(wrapper)), \"Wrapper already added\");\n        emit WrapperAdded(wrapper);\n    }\n\n    function removeWrapper(IWrapper wrapper) external onlyOwner {\n        require(_wrappers.remove(address(wrapper)), \"Unknown wrapper\");\n        emit WrapperRemoved(wrapper);\n    }\n\n    function getWrappedTokens(IERC20 token) external view returns (IERC20[] memory wrappedTokens, uint256[] memory rates) {\n        IERC20[] memory memWrappedTokens = new IERC20[](20);\n        uint256[] memory memRates = new uint256[](20);\n        uint256 len = 0;\n        for (uint256 i = 0; i < _wrappers._inner._values.length; i++) {\n            try IWrapper(uint256(_wrappers._inner._values[i])).wrap(token) returns (IERC20 wrappedToken, uint256 rate) {\n                memWrappedTokens[len] = wrappedToken;\n                memRates[len] = rate;\n                len += 1;\n                for (uint256 j = 0; j < _wrappers._inner._values.length; j++) {\n                    if (i != j) {\n                        try IWrapper(uint256(_wrappers._inner._values[j])).wrap(wrappedToken) returns (IERC20 wrappedToken2, uint256 rate2) {\n                            bool used = false;\n                            for (uint256 k = 0; k < len; k++) {\n                                if (wrappedToken2 == memWrappedTokens[k]) {\n                                    used = true;\n                                    break;\n                                }\n                            }\n                            if (!used) {\n                                memWrappedTokens[len] = wrappedToken2;\n                                memRates[len] = rate.mul(rate2).div(1e18);\n                                len += 1;\n                            }\n                        } catch { continue; }\n                    }\n                }\n            } catch { continue; }\n        }\n        wrappedTokens = new IERC20[](len + 1);\n        rates = new uint256[](len + 1);\n        for (uint256 i = 0; i < len; i++) {\n            wrappedTokens[i] = memWrappedTokens[i];\n            rates[i] = memRates[i];\n        }\n        wrappedTokens[len] = token;\n        rates[len] = 1e18;\n    }\n}\n"
    },
    "contracts/oracles/MooniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IMooniswapFactory.sol\";\nimport \"./OracleBase.sol\";\n\n\ncontract MooniswapOracle is OracleBase {\n    IMooniswapFactory public immutable factory;\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n\n    constructor(IMooniswapFactory _factory) {\n        factory = _factory;\n    }\n\n    function _getBalances(IERC20 srcToken, IERC20 dstToken) internal view override returns (uint256, uint256) {\n        IMooniswap mooniswap = factory.pools(srcToken, dstToken);\n        IERC20[] memory tokens = mooniswap.getTokens();\n        uint256[2] memory balances;\n        for (uint256 i = 0; i < 2; ++i) {\n            if (tokens[i] == _ETH) {\n                balances[i] = address(mooniswap).balance;\n            } else {\n                balances[i] = tokens[i].balanceOf(address(mooniswap));\n            }\n        }\n        if (tokens[0] == srcToken) {\n            return (balances[0], balances[1]);\n        } else {\n            return (balances[1], balances[0]);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMooniswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./IMooniswap.sol\";\n\ninterface IMooniswapFactory {\n    function pools(IERC20 token0, IERC20 token1) external view returns (IMooniswap);\n}\n"
    },
    "contracts/interfaces/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IMooniswap {\n    function getTokens() external view returns(IERC20[] memory tokens);\n}\n"
    },
    "contracts/interfaces/IOffchainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IOffchainOracle {\n    function getRate(IERC20 srcToken, IERC20 dstToken) external view returns (uint256 weightedRate);\n}\n"
    },
    "contracts/interfaces/ILendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma abicoder v2;  // solhint-disable-line compiler-version\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ILendingPoolV2 {\n    struct ReserveConfigurationMap {\n        uint256 data;\n    }\n\n    struct ReserveData {\n        ReserveConfigurationMap configuration;\n        uint128 liquidityIndex;\n        uint128 variableBorrowIndex;\n        uint128 currentLiquidityRate;\n        uint128 currentVariableBorrowRate;\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        address interestRateStrategyAddress;\n        uint8 id;\n    }\n\n    function getReserveData(address asset) external view returns (ReserveData memory);\n}\n"
    },
    "contracts/wrappers/AaveWrapperV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;  // solhint-disable-line compiler-version\n\nimport \"../interfaces/ILendingPoolV2.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract AaveWrapperV2 is IWrapper {\n    // solhint-disable-next-line var-name-mixedcase\n    ILendingPoolV2 private immutable _LENDING_POOL;\n\n    mapping(IERC20 => IERC20) public aTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToaToken;\n\n    constructor(ILendingPoolV2 lendingPool) {\n        _LENDING_POOL = lendingPool;\n    }\n\n    function addMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ILendingPoolV2.ReserveData memory reserveData = _LENDING_POOL.getReserveData(address(tokens[i]));\n            IERC20 aToken = IERC20(reserveData.aTokenAddress);\n            require(aToken != IERC20(0), \"Token is not supported\");\n            aTokenToToken[aToken] = tokens[i];\n            tokenToaToken[tokens[i]] = aToken;\n        }\n    }\n\n    function removeMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ILendingPoolV2.ReserveData memory reserveData = _LENDING_POOL.getReserveData(address(tokens[i]));\n            IERC20 aToken = IERC20(reserveData.aTokenAddress);\n            require(aToken == IERC20(0), \"Token is still supported\");\n            delete aTokenToToken[aToken];\n            delete tokenToaToken[tokens[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        IERC20 underlying = aTokenToToken[token];\n        IERC20 aToken = tokenToaToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying, 1e18);\n        } else if (aToken != IERC20(0)) {\n            return (aToken, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILendingPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface ILendingPoolV1 {\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            IERC20 aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}\n"
    },
    "contracts/wrappers/AaveWrapperV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/ILendingPoolV1.sol\";\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract AaveWrapperV1 is IWrapper {\n    IERC20 private constant _ETH = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private constant _EEE = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    ILendingPoolV1 private constant _LENDING_POOL = ILendingPoolV1(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    mapping(IERC20 => IERC20) public aTokenToToken;\n    mapping(IERC20 => IERC20) public tokenToaToken;\n\n    function addMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            (,,,,,,,,,,, IERC20 aToken,) = _LENDING_POOL.getReserveData(address(tokens[i]));\n            require(aToken != IERC20(0), \"Token is not supported\");\n            aTokenToToken[aToken] = tokens[i];\n            tokenToaToken[tokens[i]] = aToken;\n        }\n    }\n\n    function removeMarkets(IERC20[] memory tokens) external {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            (,,,,,,,,,,, IERC20 aToken,) = _LENDING_POOL.getReserveData(address(tokens[i]));\n            require(aToken == IERC20(0), \"Token is still supported\");\n            delete aTokenToToken[aToken];\n            delete tokenToaToken[tokens[i]];\n        }\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        token = token == _ETH ? _EEE : token;\n        IERC20 underlying = aTokenToToken[token];\n        IERC20 aToken = tokenToaToken[token];\n        if (underlying != IERC20(0)) {\n            return (underlying == _EEE ? _ETH : underlying, 1e18);\n        } else if (aToken != IERC20(0)) {\n            return (aToken, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    },
    "contracts/wrappers/BaseCoinWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../interfaces/IWrapper.sol\";\n\n\ncontract BaseCoinWrapper is IWrapper {\n    IERC20 private constant _BASE = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private immutable _wBase;\n\n    constructor(IERC20 wBase) {\n        _wBase = wBase;\n    }\n\n    function wrap(IERC20 token) external view override returns (IERC20 wrappedToken, uint256 rate) {\n        if(token == _BASE) {\n            return (_wBase, 1e18);\n        } else if (token == _wBase) {\n            return (_BASE, 1e18);\n        } else {\n            revert(\"Unsupported token\");\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}